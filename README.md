PythonMetaMap

When you're processing medical text through MetaMap you want a tool that handles the complexity without getting in your way. PythonMetaMap wraps the National Library of Medicine's MetaMap in a Python interface that manages servers automatically, processes files in parallel, and recovers from failures without losing progress. The project builds on ideas from the original pymm library by Srikanth Mujjiga but adds modern features like real time monitoring, clinical analysis tools, and visualization capabilities.

To get started you'll need Python 3.8 or newer and Java 8 since MetaMap runs on the JVM. Install the package with pip install pythonmetamap then run pymm install to download and configure MetaMap automatically. This downloads about a gigabyte of data and compiles the binaries so give it a few minutes. Once that's done just type pymm to open the interactive menu where you can configure settings, start servers, and begin processing files.

The simplest way to process files is through the interactive mode which you start with pymm -i or just pymm. From there you can set your input and output directories, choose how many parallel workers to use, and start processing. The system shows real time progress with CPU and memory usage for each worker. If something goes wrong the state is saved automatically so you can resume exactly where you left off by running pymm resume followed by your output directory path.

For command line usage you run pymm process input_dir output_dir to start a new batch. Add options like --workers 8 to use eight parallel processes or --timeout 600 to give each file ten minutes to process. The --background flag lets you run long jobs that continue after you close your terminal. While processing runs you can check progress with pymm status output_dir or monitor a background job with pymm monitor --follow.

Server management happens automatically but you can control it manually if needed. Run pymm server status to see what's running, pymm server start to spin up the tagger and word sense disambiguation servers, or pymm server pool --tagger 4 --wsd 4 to start multiple instances for heavy parallel processing. The system handles port conflicts automatically and monitors server health during processing.

The analysis features give you deeper insights into your results. Run pymm stats concepts output_dir to see the most common medical concepts across all your files with their semantic types and occurrence counts. For more advanced analysis try pymm analysis concepts output_dir --visualize which generates charts showing concept frequency, semantic type distribution, and co occurrence patterns. You can filter results with --filter diabetes or use presets like --preset kidney_stone to focus on specific conditions.

Clinical researchers will appreciate the enhanced analysis mode which classifies note types, extracts demographics, filters common medical noise terms, and maps concepts to OMOP vocabulary. Export your results to Excel with pymm analysis concepts output_dir --excel report.xlsx to get multiple sheets with concepts, semantic types, co occurrences, and detailed statistics.

Configuration lives in your home directory and you can view it with pymm config show or change settings with pymm config set like pymm config set max_parallel_workers 16. The interactive setup walks you through all options including MetaMap processing flags, timeout values, and Java heap size. Default settings work well for most use cases but you might increase workers for multi core machines or timeout for complex documents.

When files fail processing they're tracked automatically and you can retry them with pymm retry output_dir. The retry system increases timeouts and can filter by error type so you only reprocess files that failed for specific reasons. Check what would be retried with --dry-run before starting.

For developers the Python API gives direct access to MetaMap. Import the Metamap class, initialize it with your binary path, and call parse with a list of text strings. Each concept comes back with its CUI, score, preferred name, semantic types, source vocabularies, and position in the original text. The library handles process management, error recovery, and result parsing automatically.

Output files are CSV with columns for CUI, Score, ConceptName, PrefName, Phrase, SemTypes, Sources, and Position. Semantic types use colons as separators and sources use pipes. Position shows where concepts appear as start:length pairs. This format loads easily into pandas or Excel for further analysis.

The codebase is organized to separate concerns cleanly. Core MetaMap interaction lives in the pymm module, server management in the server module, parallel processing logic in the processing module, and all CLI code in the cli module. State management tracks progress in JSON files that persist between runs. The system uses multiprocessing for true parallelism and avoids Python's global interpreter lock.

If you run into issues check that Java is installed with pymm server check-java and that MetaMap compiled correctly. Server connection problems often resolve with pymm server restart all. For stubborn cases pymm server force-kill cleans up everything and lets you start fresh. Processing timeouts might need adjustment in configuration for very long documents.

This tool processes thousands of clinical notes efficiently on a modern workstation. Eight workers can handle about 500 documents per hour depending on length and complexity. The instance pool feature reuses MetaMap processes between files which speeds up small batches significantly. Monitor resource usage during processing to find the sweet spot for your hardware.

Citation information appears in the repository if you use PythonMetaMap in research. The project continues to evolve with community input so submit issues or pull requests on GitHub. Dr. Layth Qassem maintains the codebase with contributions from users processing everything from clinical trials to literature reviews.